[{"categories":[""],"content":"1、Java基础 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:0:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"1.1 JDK/JRE/JVM jdk是开发Java程序必备的，jdk包括jre，除此外还包括javac编译工具、java doc等工具。 jre包括jvm、java基础类库等，是运行编译后的java程序的完整集合，即运行字节码文件所需的全部内容。 jvm是Java虚拟机，在不同的系统上有不同的实现，它屏蔽了操作系统的差异，赋予了java跨平台的特性。 字节码，即.class文件，.java文件编译生成的文件。 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:1:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"1.2面向对象三大特征 封装：把对象的状态信息隐藏在对象内部，不允许外部直接访问内部信息。而是对外提供一些操作数据的接口，外部通过访问接口来操作数据。提高了数据的安全性。 继承：一个类可以继承另外一个类，通过继承可以获取别的类的所有属性和方法，提高了代码的复用性和可维护性。 多态：一个类具有多种状态，具体表现为父类变量指向子类实例。 多态的特点： 1.调用的方法不能是子类独有的 2.如果子类重写了方法，调用的就是重写后的方法，否则调用的是父类的方法。 3.对象类型与引用类型直接具有继承或实现的关系 4.具体调用的是哪个方法只有在程序运行期间才能决定 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:2:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"1.3接口和抽象类 相同点： 都可以包含抽象方法 都可以有方法的默认实现 都不能被实例化 区别： 抽象类只能继承一个，接口可以实现多个 接口中成员变量只能是public static final，抽象类没有限制，默认是default 接口强调的是行为，实现什么接口就具有什么行为，抽象类强调的是所属关系，主要用于代码复用。 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:3:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"1.4深浅拷贝 浅拷贝：在堆上复制一个对象，对于对象中的引用类型，直接复制引用类型的地址。 深拷贝：在堆上复制一个对象，对于对象中的引用类型，也会在堆上复制新的对象。 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:4:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"1.5Object类 Object类是所有类的父类，一些常见方法： equals：默认是比较引用地址，即==，String类重写了该方法，所以String的equals比较的是字符串内容。 hashCode()：native方法，返回对象的哈希码 toString()：默认是输出哈希码的16进制字符串 clone()：浅拷贝，返回对象的拷贝对象。 其他：wait,notify，用于协调线程间的工作，只能在Synchronized 中使用 ==和equals()区别： ==比较引用地址是否相等，对于基本类型比较的是值是否相等。 equals()如果没有重新该方法，默认与==作用一致，如果重写了该方法，则是比较对象的内容是否一致。 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:5:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"1.6hashCode() 该方法是返回对象的哈希值，用于确定在哈希表中的索引位置。 不同的对象可能会有一样的hashCode，称为哈希碰撞。 简言之，对象相等则hashcode一定相等，hashcode相等对象不一定相等。 重写equals方法必须重写hashCode方法，否则可能会导致两个相等的对象hashcode却不一致，这样会导致hashMap出现问题。 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:6:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"1.7String类 String是不可变的，并且String类是final类，不可被继承。内部是使用私有的final char数组，(jdk1.9后改为byte数组，更加节省空间)，并且没有提供修改数组的方法。 StringBuilder和StringBuffer都是可变的，通过append方法修改字符串。前者不是线程安全的，后者是线程安全的，前者的性能比后者高约10%。单线程操作可变字符串使用StringBuilder，多线程操作可变字符串使用StringBuffer。 此外，String类通过+进行连接，实际还是通过StringBuilder的append方法实现的，循环内使用+的方式会导致每次连接字符串都要新建StringBuilder对象，造成浪费。 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:7:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"1.8字符串常量池 字符串常量池 是JVM为了提高性能和减少内存消耗针对String类专门开辟的一片区域，主要目的是为了避免字符串的重复创建。 String s1 = new String(“abc”)创建了几个对象？ 两个。首先在常量池中创建字符串“abc”的引用，随后创建的String对象指向这个引用。 一个。如果常量池中已经存在字符串“abc”的引用，那么只会创建一个string对象并指向这个引用。 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:8:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"1.9包装类型 基本数据类型对应的引用类型。包装类型没有默认值，成员变量的基本数据类型有默认值。 缓存机制：整数类型缓存了[-128,127]，浮点数没有缓存机制。 自动拆装箱：基本数据类型和包装类型自动转换的过程。这一过程其实就是调用包装类的valueOf()方法，和xxxValue()方法。频繁拆装箱会影响性能。 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:9:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"1.10浮点数精度丢失/超过long数据表示 需要精确运算结果使用BigDecimal类（涉及到钱的场景）,超过long的数据可以使用BigInteger类，内部使用int[]数组进行运算。 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:10:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"1.11异常 异常的顶级类是Throwable类，其两个重要子类分别是：Exception和Error。 异常通常可以被捕获并处理，error通常无法被程序处理，例如虚拟机运行错误或虚拟机内存不够。 异常可以分为运行时异常，即继承自RuntimeException，和非运行时异常。 后者会在编译期检查，如果没有捕获或抛出异常就无法通过编译，例如ClassNotFoundException、IO异常等 前者常见的异常有：空指针，数组越界，类型转换异常，参数异常等等。 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:11:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"1.12try-catch-finally try和finally都有return，会返回什么？ 在try执行return前会将返回值暂存在一个本地变量中，然后执行finally语句，随后finally中的return值覆盖了之前的值，最终将返回finally中的值。 finally一定会被执行吗？ 通常情况一定会执行，但如果线程被死亡或者关闭JVM可能会导致无法执行finally。 通常我们在finally中执行关闭资源的操作，可以通过语法try-with-resources替换之前的操作，可以使代码更加简短清晰。 例如，执行完后将自动关闭资源，无需手动关闭。 try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File(\"test.txt\"))); BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File(\"out.txt\")))) { int b; while ((b = bin.read()) != -1) { bout.write(b); } } catch (IOException e) { e.printStackTrace(); } ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:12:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"1.13反射 通过反射可以获取到任意类的所有属性和方法，并且可以调用这些方法。 框架中通常会用大量用到反射机制，以及Jdk的动态代理都用到了反射。 知道具体类的情况可以通过类名.class获取Class 有对象实例的情况可以通过对象.getClass()获取Class 不知道具体类的话可以通过Class.forName()或者ClassLoader.getSystemClassLoader().loadClass() 2.Java集合 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:13:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"2.1.概览 大体上可以分为Collection和Map两类。 前者包括List、Set、Queue，后者包括Map。 List线性表，存储元素有序可重复。 Set存储元素无序且不可重复。 Queue是队列，有序可重复，符合FIFO（先进先出）原则。 Map存储键值对，无序键不可重复，值可重复。 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:14:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"2.2ArrayList和LinkedList 前者底层使用数组，后者使用双向链表，绝大数情况都使用前者，连后者的作者都说几乎不适用LinkedList。 前者使用数组，可能会导致存储空间的浪费，随机获取元素很快，但是在中间位置进行插入或删除操作较费时，因为涉及到元素位置的移动。后者数据可以分散存储而不必存储在连续的空间。 ArrayList：初始容量为10（第一次添加元素才会进行初始化），随后每次进行1.5倍扩容。不是线程安全的，vector是一种较早的实现，是线程安全的，但是基本已经弃用了。 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:15:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"2.3HashSet、LinkedHashSet、TreeSet 三者都不是线程安全的，底层结构分别为HashMap（无序）、链表+HashMap(元素插入取出满足FIFO)、红黑树（支持对元素进行排序）。 Set存储的唯一性使用了HashMap的键的唯一性的特点，通过键的唯一保证元素的唯一。 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:16:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"2.4Queue Deque（双端队列）接口扩展了Queue接口，ArrayDeque和LinkedList都实现了Deque接口，可以作为双端队列使用，还可以作为栈Stack使用。 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:17:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"2.5HashMap和HashTable和ConcurrentHashMap 前者不是线程安全的，后两者是线程安全的。其中HashTable基本被淘汰了，如果要保证线程安全就使用ConcurrentHashMap。 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:18:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"2.6HashMap和TreeMap 前者是无序的，后者可以根据键进行排序，默认是键的升序，也可以指定排序的比较器。 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:19:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"2.7HashMap底层 底层是数组+链表+红黑树，扩容是2倍扩容。 put元素过程：首先计算Key的hashcode，根据hashcode计算出数组的索引位置，如果该位置为空，直接存储节点，否则判断节点的key值是否一致，一致则直接覆盖节点的Value，否则依次往后比较Key，如果key都不一样，就将节点存储在链表末尾，随后判断是否需要进行树化。 为什么容量为2的幂次方？ 根据hashcode计算数组索引时，采用了(n-1)\u0026hash的方式，当数组长度为2的幂次方时，对长度取余等价于(n-1)\u0026hash，位运算是比取余运算快的。 扩容原理？ 当元素个数大于扩容阈值时，就会进行扩容操作。扩容阈值等于容量乘以负载因子，默认是0.75。 扩容首先将容量扩大2倍，随后将节点重新进行散列，这是一个比较费时的操作。散列的规则是：将hashcode与原数组长度进行与运算，为0则索引为原索引，否则索引为（原索引+原容量） ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:20:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"2.8 ConcurrentHashMap 线程安全，1.7采用分段数组+链表，1.8变成了数组链表和红黑树。线程安全由原来的分段锁变为了synchronized和CAS。synchronized 只锁定当前链表或红黑二叉树的首节点。并发度是数组的大小。 3.IO ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:21:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"3.1概览 输入流基类：InputStream（字节流）/Reader（字符流） 输出流基类：OutputStream（字节流）/Writer（字符流） ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:22:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"3.2InputStream/OutputStream FileInputStream 是一个比较常用的字节输入流对象，通常会配合 BufferedInputStream（字节缓冲输入流）来使用。用来以字节流的形式读取文件内容。 类似的，FileOutputStream 是一个比较常用的字节输出流对象，通常会配合 BufferedOutputStream（字节缓冲输出流）来使用。用来以字节流的形式输出文件内容。 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:23:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"3.3Reader/Writer 字符流主要为了解决字符编码问题，如果使用字节流读取文本内容，很容易出现乱码，而使用字符流就不会出现乱码问题。 InputStreamReader 是字节流转换为字符流的桥梁，其子类 FileReader 是基于该基础上的封装，可以直接操作字符文件。 类似的，OutputStreamWriter 是字节流转换为字符流的桥梁，其子类 FileWriter 是基于该基础上的封装，可以直接操作字符文件。 BufferedReader （字符缓冲输入流）和 BufferedWriter（字符缓冲输出流）类似于 BufferedInputStream（字节缓冲输入流）和BufferedOutputStream（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:24:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"3.4IO的设计模式 装饰器模式：用于增强原有功能。例如通过BufferedInputStream增强FileInputStream。BufferedInputStream的构造函数其中的一个参数就是InputStream 适配器模式：主要用于接口互不兼容的类的协调工作。InputStreamReader 和 OutputStreamWriter 就是两个适配器(Adapter)， 同时，它们两个也是字节流和字符流之间的桥梁。InputStreamReader 使用 StreamDecoder （流解码器）对字节进行解码，实现字节流到字符流的转换， 工厂模式：工厂模式用于创建对象，NIO 中大量用到了工厂模式。例如Files.newInputStream()； 观察者模式：NIO 中的文件目录监听服务使用到了观察者模式。NIO 中的文件目录监听服务基于 WatchService 接口和 Watchable 接口。WatchService 属于观察者，Watchable 属于被观察者。 参考：Java IO设计模式总结 | JavaGuide(Java面试+学习指南) 4.多线程 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:25:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"4.1多线程几种方式 实现runnable接口并重写run方法，用的较多 继承Thread类，并重写run方法，用的较少 实现callable接口，并重写call方法。 runnable和callable接口区别：前者没有返回值，后者可以返回执行结果。 不调用start()方法，直接执行run()方法可以吗？ start将启动一个新线程去执行run方法，直接执行run()方法不会启动新线程。 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:26:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"4.2线程的状态 java中线程共有六种状态，分别是： 初始 运行 等待 超时等待 阻塞 结束 线程创建完毕后处于初始状态，调用start方法后进入运行状态，运行状态下调用wait()方法将进入等待或者超时等待，如果获取锁失败将进入阻塞状态，线程执行完毕后进入结束状态。 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:27:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"4.3线程和进程 进程是系统运行程序的最小单位，线程可以看作更轻量级的执行单位。系统切换进程开销较大，切换线程开销小。 一个进程可以包含多个线程，多个线程共享堆和方法区，但每个线程有自己的程序计数器、栈和本地方法栈。 为什么程序计数器、栈和本地方法栈是私有的？ 每个线程有自己的执行任务，程序计数器记录着线程的下一条指令的位置；此外在上下文切换时记录着当前执行的位置，以便可以正确恢复执行。 栈则保存了方法执行的一些信息，方法的执行就是栈帧入栈和出栈的过程。 本地方法栈则是为栈提供本地方法服务。 堆和方法区 堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:28:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"4.4为什么使用多线程 更好的利用多个cpu，提高运行效率，提高并发量。 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:29:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"4.5死锁 多个线程都持有某些资源，同时在等待别的线程释放资源，最终造成了所有线程都在等待的局面。 如何避免死锁？ 线程获取锁的顺序要一致。 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:30:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"4.6锁/线程同步/线程通信 synchronized：用于保证资源只被一个线程访问，可用于方法或代码块。保证了资源共享问题，但无法解决线程协调工作，此时就需要wait()和notify()出场了，这两个方法只能在synchronized内使用，当不满足某个条件时调用wait()方法，使线程进入等待状态，当满足某个条件时，通过别的线程调用notifyAll()（或notify()）进行唤醒。 ReentrantLock：与synchronized作用相同，但更加灵活，可以选择公平锁或非公平锁，默认非公共锁。通过Condition类可以实现wait和notify的功能。 volatile：只能修饰变量，可以保证变量的可见性，每次使用该变量都需要到主存去取。 volatile和synchronized异同：**前者只能保证可见性，不能保证原子性，后者都可以保证。**前者性能更好。前者只能用于变量，后者可以用于方法和代码块。前者主要用于解决多个线程间变量的可见性，后者是解决访问资源的同步性。 synchronized和ReentrantLock都属于可重入锁，一个线程在获取锁后仍然可以再次获取锁。同时也是悲观锁，（独占锁），悲观锁多用于写比较多的情况。 乐观锁一般使用版本号或CAS算法实现。 此外，ReadWriteLock可以使读锁和写锁分离，允许多个读锁同时读（前提是没有写锁），可以进一步提高并发量。 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:31:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"4.7wait和sleep区别 前者使线程进入等待状态直到被唤醒，会释放锁，后者是暂停线程的执行，不会释放锁。 wait是Object的方法，sleep是Thread的方法。 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:32:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"4.8ThreadLocal 为每个线程创建副本值。底层是通过ThreadLocalMap实现的，原理就是使用线程作为key，获取其对应的值。 ThreadLocal导致的内存泄漏问题？如何避免？ key为弱引用，而value为强引用。假如ThreadLocal没有被强引用的话，在GC清理时就会把key清理掉而value不会清理，就会造成内存泄漏。使用完ThreadLocal后手动调用remove()方法 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:33:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":[""],"content":"4.9线程池 为什么使用线程池？ 频繁创建销毁线程会造成资源浪费，通过线程池可以降低资源消耗，而且方便管理线程。 如何创建线程池？ 通过**ThreadPoolExecutor**：阿里推荐的方式。 通过Executors工具类，内置了若干种类型的线程池。（为什么不推荐这种方式？任务队列无限量或者线程无限量可能导致OOM） 另外，线程池execute()方法用于执行runnable类型的任务，且没有返回值， 而submit()方法可以执行Runnable或者Callable类型的任务，且返回值为Future。 调用future.get()即可获取执行结果，且此方法会阻塞线程，只有任务执行完返回结果后才会继续执行get()后的代码。 ","date":"2023-02-24","objectID":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/:34:0","tags":[""],"title":"Test","uri":"/java%E6%A0%B8%E5%BF%83%E6%A6%82%E8%A6%81/"},{"categories":["博客搭建"],"content":"这是Hugo搭建博客的第二期，第一期请参考：Hugo搭建博客（上） - Okzhp ","date":"2023-01-03","objectID":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-2/:0:0","tags":["Hugo","LoveIt"],"title":"Hugo搭建博客（下）","uri":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-2/"},{"categories":["博客搭建"],"content":"1.Hugo(LoveIt)美化 本站对主题的改造体现在以下几个方面： 鼠标点击爆炸/评论区输入框输入爆炸+震动 卜算子访问量统计及网站运行时间 设置valine评论 副标题引用一言api 注意，本文所述js文件都放在static/js文件夹下。 hugo静态文件一般放在static或者assets文件夹下，但是favicon.png在assets文件夹下无法打包至public，因此我把所有静态文件都放在static文件夹下了。 ","date":"2023-01-03","objectID":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-2/:1:0","tags":["Hugo","LoveIt"],"title":"Hugo搭建博客（下）","uri":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-2/"},{"categories":["博客搭建"],"content":"1.鼠标点击爆炸和输入框爆炸 效果：点击页面即可看到效果，文末评论框也可看到效果。 出处：点击特效未找到出处，输入特效是我在github中发现的一个项目传送门. 将click-boom.js、input-boom.js下载至js文件夹。 将themes/LoveIt/layouts/partials/assets.html复制到layouts/partials/assets.html（根目录下的文件优先级高于主题内的文件，在外部改动将不影响后续主题版本更新） 编辑assets.html，在末尾引入以上两个js \u003c!-- 点击爆炸特效 --\u003e \u003cscript type=\"text/javascript\" src=\"/js/click-boom.js\"\u003e\u003c/script\u003e \u003c!-- 输入框爆炸+震动 --\u003e \u003cscript type=\"text/javascript\" src=\"/js/input-boom.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\"\u003e POWERMODE.colorful = true; // make power mode colorful POWERMODE.shake = true; // turn off shake document.body.addEventListener('input', POWERMODE); \u003c/script\u003e 至此，两个特效已经实现了。但是评论系统在开发环境默认是关闭的，LoveIt集成了好几种评论系统，以valine为例，在配置文件中搜索valine，把其下的enable = false改为true，然后在执行hugo server -e production即可看到评论系统。此时评论系统还只是半成品，需要设置其服务端才可以正常使用。这个后文再讲。 ","date":"2023-01-03","objectID":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-2/:1:1","tags":["Hugo","LoveIt"],"title":"Hugo搭建博客（下）","uri":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-2/"},{"categories":["博客搭建"],"content":"2.卜算子访问量统计/网站运行时间 官网传送门 效果如下，（本地网络的次数有误，上线后正常） 在assets.html引入js处添加以下： \u003cscript async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"\u003e\u003c/script\u003e \u003c!-- 运行时间 --\u003e \u003cscript type=\"text/javascript\" src=\"/js/cal-runtime.js\"\u003e\u003c/script\u003e 在static/js文件夹下创建cal-runtime.js，粘贴以下内容： /* 站点运行时间 */ function siteTime() { let seconds = 1000; let minutes = 60000; let hours = 3600000; let days = 86400000; let years = 31536000000; let diff = new Date() - new Date('12/31/2022 00:00:00'); // let diffYears = Math.floor(diff / years); let diffDays = Math.floor(diff / days); let diffHours = Math.floor((diff%days)/hours); let diffMinutes = Math.floor((diff%hours) / minutes); let diffSeconds = Math.floor((diff%minutes) / seconds); let runbox = document.getElementById('run-time'); runbox.innerHTML = '本站已运行\u003ci class=\"far fa-clock fa-fw\"\u003e\u003c/i\u003e ' + ((diffDays \u003c 10) ? '0' : '') + diffDays + ' 天 ' + ((diffHours \u003c 10) ? '0' : '') + diffHours + ' 时 ' + ((diffMinutes \u003c 10) ? '0' : '') + diffMinutes + ' 分 ' + ((diffSeconds \u003c 10) ? '0' : '') + diffSeconds + ' 秒 '; } setInterval(siteTime, 1000); 将themes/LoveIt/layouts/partials/footer.html复制到layouts/partials/footer.html 在\u003cdiv class=\"footer-container\"\u003e这一行下边添加以下： \u003c!-- 运行时间 --\u003e {{ if .Site.Params.runtime.enable -}} \u003cdiv class=\"footer-line\"\u003e \u003cspan id=\"run-time\"\u003e\u003c/span\u003e \u003c/div\u003e {{- end -}} \u003c!-- 访问量 --\u003e \u003c!-- busuanzi --\u003e {{ if .Site.Params.busuanzi.enable -}} \u003cdiv class=\"busuanzi-footer\"\u003e {{ if .Site.Params.busuanzi.sitePV -}} \u003cspan id=\"busuanzi_container_site_pv\"\u003e \u003ci class=\"far fa-eye\"\u003e\u003c/i\u003e \u003cspan id=\"busuanzi_value_site_pv\"\u003e\u003c/span\u003e次 \u003c/span\u003e {{- end -}} \u0026nbsp;|\u0026nbsp; {{ if .Site.Params.busuanzi.siteUV -}} \u003cspan id=\"busuanzi_container_site_uv\"\u003e \u003ci class=\"fas fa-users\"\u003e\u003c/i\u003e \u003cspan id=\"busuanzi_value_site_uv\"\u003e\u003c/span\u003e人次 \u003c/span\u003e {{- end -}} \u003c/div\u003e {{- end -}} 至此，卜算子访问量统计和网站运行时间已经实现。 在配置文件中，可以找到 [params.runtime]和 [params.busuanzi]这两项配置，通过这些开关可以控制访问量和运行时间是否进行展示 ","date":"2023-01-03","objectID":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-2/:1:2","tags":["Hugo","LoveIt"],"title":"Hugo搭建博客（下）","uri":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-2/"},{"categories":["博客搭建"],"content":"3.valine评论 官网传送门 需要登录leanCloud，创建一个应用，获取AppId和AppKey，并在配置文件中进行配置(ctrl+f查找)，除此外还需配置severUrls才可正常使用评论功能。 三个参数分别如下图： 如果有域名，最好绑定自己的域名。 设置好以上三个参数就可以正常使用评论功能了。valine已经没有邮箱评论通知的功能了，如果需要评论邮箱提醒需要使用valine-admin，使用方法请自行查阅在此不再赘述。还有其他几种评论系统，请自行尝试。 顺带提一下，在后台也可以对评论进行一些操作： ","date":"2023-01-03","objectID":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-2/:1:3","tags":["Hugo","LoveIt"],"title":"Hugo搭建博客（下）","uri":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-2/"},{"categories":["博客搭建"],"content":"4.副标题引用一言Api 官网一言开发者中心 | 用代码表达言语的魅力，用代码书写山河的壮丽。 (hitokoto.cn) 首先在配置文件中搜索subtitle，将其值设为\" \"，注意有一个空格，如果没有空格将不存在副标题。空格只是打开开关，然后由js设置为一言的内容。 类似的，在上文提到的assets.html末尾添加以下内容： \u003c!-- typeit --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/typeit@6.1.1/dist/typeit.min.js\"\u003e\u003c/script\u003e \u003c!-- 副标题文字请求一言接口 --\u003e \u003cscript type=\"text/javascript\"\u003e // a动画b漫画c游戏d文学e原创f来自网络g其他h影视i诗词j网易云k哲学l抖机灵 let url = \"https://v1.hitokoto.cn/?c=a\u0026c=b\u0026c=k\u0026c=j\u0026c=i\u0026c=c\u0026encode=text\" oneWord(); function oneWord() { let req = new XMLHttpRequest(); req.open(\"GET\", url); req.responseType = \"text\" req.send(); req.onload = function() { let text = \"一个人在他停止学习的时候就已经死了\"; if (req.status === 200) { // 分析响应的 HTTP 状态 text = req.responseText; } new TypeIt(\"#id-1\", { strings: text, }).go(); }; } \u003c/script\u003e 这里需要引入typeit的js，即使主题已经有了包含了typeit，但此处不引入会导致副标题多一个换行。 ","date":"2023-01-03","objectID":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-2/:1:4","tags":["Hugo","LoveIt"],"title":"Hugo搭建博客（下）","uri":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-2/"},{"categories":["博客搭建"],"content":"2.部署及优化 秉着能省则省的原则，我将用零成本打造一个尽可能舒适的博客体验。 ","date":"2023-01-03","objectID":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-2/:2:0","tags":["Hugo","LoveIt"],"title":"Hugo搭建博客（下）","uri":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-2/"},{"categories":["博客搭建"],"content":"1.部署到github pages 当调整完布局和内容后，我们就可以开始部署（托管）到github pages了。 首先需要在github建立一个public仓库，仓库名为 用户名.github.io。 在博客的根目录执行hugo命令，此命令将在public文件夹中构建出该博客网站。 使用git前先设置git的用户名和邮箱： git config --global user.name \"Your Name\" git config --global user.email \"email@example.com\" git网络不太稳定，很有可能push失败，最好使用翻墙网络。 在cmd中设置http和https代理方法： set http_proxy=http://127.0.0.1:端口号 set https_proxy=http://127.0.0.1:端口号 通常clash http端口号为7890 cd public #将public初始化为git仓库，后续将通过git管理内容 git init # 关联远程仓库 git remote add origin https://github.com/okzhp/okzhp.github.io.git # 将所有内容添加到git本地仓库 git add . git commit -m \"第一次提交\" #提交到git远程仓库 首次提交可能需要身份认证，点击在浏览器中认证 git push -u origin master push完后在仓库页面，选择部署分支为当前分支master， github将自动部署该博客，通过用户名.github.io即可访问。 后续更新文章通过命令: #查看仓库状态 git status git add . git commit -m \"填写提交备注\" # 如果push失败，可能是网络不行或者远程仓库和本地仓库内容有差异，请先执行git pull master然后再push git push origin master ","date":"2023-01-03","objectID":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-2/:2:1","tags":["Hugo","LoveIt"],"title":"Hugo搭建博客（下）","uri":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-2/"},{"categories":["博客搭建"],"content":"2.域名申请/绑定 通过用户名.github.io虽然可以访问，但还差点意思，如果通过自己的域名访问那就更好了。 国内许多平台可以买域名，但是国内的域名需要备案才能使用。因此我选择了国外的域名，而且是免费的。 这部分涉及的网站需要科学上网才可访问，请自行解决。 我申请免费域名的方法暂时已经失效了，域名的问题请自行解决，网络上应该有许多免费域名的获取方法。 在域名服务商的管理台正确配置DNS解析。 github.io的ip地址为： 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 在DNS解析处添加以下两条配置： A类型 你的域名(例如okzhp.tk) 上面四个ip之一(例如185.199.108.153) CNAME www 仓库地址(例如okzhp.github.io) 上边的配置将okzhp.tk解析到185.199.108.153，将www.okzhp.tk解析到okzhp.github.io DNS解析通常要几分钟才能生效，随后在github page页面配置该域名即可： 至此就完成了对域名的配置。 ","date":"2023-01-03","objectID":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-2/:2:2","tags":["Hugo","LoveIt"],"title":"Hugo搭建博客（下）","uri":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-2/"},{"categories":["博客搭建"],"content":"2.图床配置 图床，即存储图片的服务器，通过一个链接即可方便的进行访问。例如本站图片都是存储在七牛云服务器上，配置完图床对于处理图片将会非常的方便。本站的图床配置是通过七牛云和PicGo实现的。 注意：图床配置需要有自己的域名才可以，因为七牛云只提供一个有效期一个月的仅供测试用的域名，因此需要绑定自己的域名。七牛云有若干个地区，国内的地区使用域名必须有备案，换言之，没有备案的域名只能使用国外的存储空间。例如我用的存储区域就在北美。 七牛云 首先注册登录七牛云，需要进行身份认证和邮箱绑定，完成后每个月将有10g的存储空间和10g的下载流量。对于个人博客来说，简直不要太完美。 首先打开对象存储-空间管理-新建空间，如图： 新建一个空间，创建完毕后，在对应位置记住红框内的五个参数，后面要使用： PicGo 在PicGo is Here | PicGo页面下载PicGo。在设置中进行参数配置： 设定访问网址即七牛云提供的临时域名或者绑定的域名。区域则填对应的区域代码：华东z0，华北z1，华南z2，北美na0，东南亚as0 存储路径则是你上传的路径。 复制一张图片，使用ctrl+shift+p快捷键进行上传，上传成功即可。 随后在md编辑器typora偏好设置-图像 选择picgo安装路径： 配置完毕后，在typora粘贴图片时将自动上传至七牛云并引用其超链接，可以很方便的引用图片。 typora目前的版本都是收费的，其支持图床配置的最后一个免费版本是0.9.96 ","date":"2023-01-03","objectID":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-2/:2:3","tags":["Hugo","LoveIt"],"title":"Hugo搭建博客（下）","uri":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-2/"},{"categories":["博客搭建"],"content":"3.后续 整个博客的搭建大概花了三天时间，第一天搭建了主要的骨架，第二天处理域名和valine评论相关，第三天做了一些美化和图床处理。本打算第四天发文记录，结果拖到第五天才开始下笔，愣是写了两天才才把大致过程略讲了一遍，而且有很多地方一笔带过了。总之，这也是一个总结复盘的过程。 个人认为，博客还存在以下几个方面待改进： 图片存储在国外，访问速度较慢 域名虽是免费的，但没有备案无法在国内使用，且有效期仅有一年。 尚未完成部署脚本一键部署 评论邮箱提醒功能缺失（由于leanCloud自动唤醒被禁止了） 至此，博客已经搭建完毕🤖 如果有问题欢迎留言讨论🤖 总之，本次博客搭建参考了大量网络内容，包括但不限于以下参考： Github Pages + Hugo 搭建个人博客 - 渣渣的夏天 (zz2summer.github.io) Hugo系列(3.1) - LoveIt主题美化与博客功能增强 · 第二章 - Yulin Lewis’ Blog (lewky.cn) ","date":"2023-01-03","objectID":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-2/:3:0","tags":["Hugo","LoveIt"],"title":"Hugo搭建博客（下）","uri":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-2/"},{"categories":["博客搭建"],"content":"这是Hugo搭建博客的第一期，第二期请参考：Hugo搭建博客（下） - Okzhp ","date":"2023-01-02","objectID":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-1/:0:0","tags":["Hugo","LoveIt"],"title":"Hugo搭建博客（上）","uri":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-1/"},{"categories":["博客搭建"],"content":"1.前言 ​ 很早之前就想要搭建一个博客，奈何伊始眼界太窄，不知以何种方式搭建博客。当时还在github上搜一些博客项目，譬如nbBlog、halo等。也听说过github搭建博客，但却不了解它到底是个什么形态。由于种种信息差，我很长时间内一直以为需要买一台服务器然后才能搭建自己的博客，最终也就搁置了。 后来了解到hugo，花了几天时间研究，没少折腾，最终也算有了博客的雏形。谨以此文作为自己的第一篇博客，记录一下博客搭建的过程。 提示\r学习新技术的一种绝佳方式就是看官方文档。 本文对于一些说明可以直接点击跳转到官网说明。 Let’s Begin！ 相关文档说明\r通常github上较火的项目都会有文档说明，有些有中文说明，如果没有中文说明的话，可以尝试google搜索项目名 中文，通常可以找到相关文档。 以下列出本文参考的一些文档和链接： Hugo官方文档 Hugo中文文档 LoveIt官方文档中文 ","date":"2023-01-02","objectID":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-1/:1:0","tags":["Hugo","LoveIt"],"title":"Hugo搭建博客（上）","uri":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-1/"},{"categories":["博客搭建"],"content":"2.何为Hugo? Hugo是一个用go语言实现的静态网站构建框架，github上star数64.5k（截止到2023.1.2）。Hugo的官网是这么介绍的：The world’s fastest framework for building websites。世界上最快的构建网站的框架，简单来说就是一个用来构建静态网站的框架。 需要注意的是，hugo有许多主题可选，想要构建自己的博客，需要选一款中意的主题，然后在此基础上进行配置或自定义修改。 静态网站构建框架对比\rHugo、Hexo、Jekyll。 博客生成器也叫静态网站生成器，是一种将文本文档通过一些处理生成一个有机整体的html语言的网站，由于生成的静态网页可以直接托管在主机或vps上，配合nginx或Apache就可以供网民使用。github与gitcafe等网站也支持免费托管静态网页文件，非常方便。 编译速度：Hugo\u003ehexo\u003eJekyll Hugo使用go语言是一种编译型语言，速度非常快，而Jekyll使用ruby编写，hexo使用nodejs编写，ruby与nodejs都是面向对象的高级解释型语言，执行效率比编译型语言要低。 ","date":"2023-01-02","objectID":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-1/:2:0","tags":["Hugo","LoveIt"],"title":"Hugo搭建博客（上）","uri":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-1/"},{"categories":["博客搭建"],"content":"3.使用Hugo前置条件 Hugo官网推荐使用Hugo前安装Git和Go。在我搭建博客的过程中，git是必须的，go并非必须。 使用Hugo搭建博客需要安装Hugo和Git。以下仅对Hugo安装进行说明，git安装请自行搜索。 Hugo有两个版本，这是官网安装Hugo的说明： 安装方式有好几种，选择一种安装即可： 直接下载编译好的exe文件。下载地址 通过包管理器安装（一行命令即可，但需要首先安装对应包管理器）。 通过Go安装构建。 简单来说，需要先安装git以及1.18版本以上的go并设置好环境变量。然后执行下面两条命令： #通过go安装Hugo go install -tags extended github.com/gohugoio/hugo@latest #查看Hugo版本，注意是extended版本 hugo version ","date":"2023-01-02","objectID":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-1/:3:0","tags":["Hugo","LoveIt"],"title":"Hugo搭建博客（上）","uri":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-1/"},{"categories":["博客搭建"],"content":"4.Hugo快速上手 注意：Hugo使用md文件，常用的md文件编辑器是typora，typora目前版本都是收费的，分享一个免费的版本点我下载，该版本(0.9.96)应该是支持后文提到图床配置的最后一个免费版本。 快速上手参考官网quick start。 至此，如果在命令行中执行hugo和git如果没有报错，即可开始下一步了。 #创建一个quickstart网站的骨架 hugo new site quickstart #进入该文件夹 cd quickstart 然后就需要在主题列表选择一个主题，并复制其git地址，比如我选择的就是LoveIt，然后执行： #将主题clone到themes/LoveIt文件夹下 git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt #注意，现在只是下载了主题但还没有应用，打开quickstart文件夹下的config.toml 添加下面两行配置： theme = 'LoveIt' buildDrafts = true 前者指定了主题，后者指定了将草稿也进行构建（新建的文章默认是草稿）。 #创建第一篇文章first_post,该文章在content/posts文件夹下，这是默认的文章路径 hugo new posts/first_post.md #在编辑好文章后 执行以下命令启动网站。 hugo serve 然后在对应端口即可访问网站。 此时，网站还非常简陋，如下： 至此，骨架已经搭建完毕。下面将对界面进行基本的配置。 ","date":"2023-01-02","objectID":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-1/:4:0","tags":["Hugo","LoveIt"],"title":"Hugo搭建博客（上）","uri":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-1/"},{"categories":["博客搭建"],"content":"5.LoveIt初配置 注意\r该部分配置仅针对LoveIt主题，不同的主题配置有所差异，因此务必参考官方文档说明。LoveIt的官方文档还是比较详尽的，而且有中文版。\r技巧\r官网的quick start就像数学课本的例题一样， 例：1+1=2，既然已知1+1=2，那我们就可以推导出$c = \\pm\\sqrt{a^2 + b^2}$ and \\(f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi\\) 页面的外观基本上取决于你的配置文件config.toml（或者config.yaml），因此一个健全的config.toml就可以实现基本的外观布局。 经过简单的配置后，现在的配置文件应该是这样： baseURL = 'http://example.org/' languageCode = 'en-us' title = 'My New Hugo Site' theme = 'LoveIt' buildDrafts = true 下面罗列一些基本的配置，了解基本的配置有助于理解配置的原理。尝试将以下配置追加在配置文件中。 尝试替换配置中的一些[ICON](Find the Perfect Icon for Your Project in Font Awesome 5 | Font Awesome) # 设置默认的语言 [\"en\", \"zh-cn\", \"fr\", \"pl\", ...] defaultContentLanguage = \"zh-cn\" # 菜单，也就是最上边的一排栏目 [menu] [[menu.main]] weight = 1 identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" [[menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" [[menu.main]] weight = 3 identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" [[menu.main]] weight = 4 identifier = \"about\" pre = \"\" post = \"\" name = \"关于\" url = \"/about\" title = \"\" [[menu.main]] weight = 5 identifier = \"github\" pre = \"\u003ci class='fab fa-github fa-fw' aria-hidden='true'\u003e\u003c/i\u003e\" post = \"\" name = \"\" url = \"https://github.com/okzhp\" title = \"GitHub\" # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 [\"fixed\", \"normal\", \"auto\"] desktopMode = \"fixed\" # 移动端导航栏模式 [\"fixed\", \"normal\", \"auto\"] mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Okzhp\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = '\u003ci class=\"fab fa-joomla\"\u003e\u003c/i\u003e' # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = false # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2022 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' 上边罗列了最基本的header、菜单栏已经footer的配置。以下为一个较为完整的配置文件（仅供参考）： baseURL = \"https://okzhp.github.io\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" # 网站标题 title = \"Okzhp\" # 是否构建草稿 buildDrafts = true # 设置默认的语言 [\"en\", \"zh-cn\", \"fr\", \"pl\", ...] defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 [\"en\", \"zh-CN\", \"fr\", \"pl\", ...] languageCode = \"zh-CN\" # 语言名称 [\"English\", \"简体中文\", \"Français\", \"Polski\", ...] languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true # 默认每页列表显示的文章数目 paginate = 12 # 谷歌分析代号 [UA-XXXXXXXX-X] googleAnalytics = \"\" # 版权描述，仅仅用于 SEO copyright = \"\" # 是否使用 robots.txt enableRobotsTXT = true # 是否使用 git 信息 enableGitInfo = false # 是否使用 emoji 代码 enableEmoji = true # 忽略一些构建错误 ignoreErrors = [\"error-remote-getjson\", \"error-missing-instagram-accesstoken\"] # 作者配置 [author] name = \"Caspian\" email = \"1241683615@qq.com\" link = \"\" # 菜单配置 [menu] [[menu.main]] weight = 1 identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" [[menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" [[menu.main]] weight = 3 identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" [[menu.main]] weight = 4 identifier = \"about\" pre = \"\" post = \"\" name = \"关于\" url = \"/about\" title = \"\" [[menu.main]] weight = 5 identifier = \"github\" pre = \"\u003ci class='fab fa-github fa-fw' aria-hidden='true'\u003e\u003c/i\u003e\" post = \"\" name = \"\" url = \"https://github.com/okzhp\" title = \"GitHub\" [params] # 网站默认主题样式 [\"auto\", \"light\", \"dark\"] defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"https://github.com/okzhp\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # [\"sha256\", \"sha384\", \"sha512\", \"md5\"] fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站标题, 用于 Open Graph 和 Twitter ","date":"2023-01-02","objectID":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-1/:5:0","tags":["Hugo","LoveIt"],"title":"Hugo搭建博客（上）","uri":"/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-1/"},{"categories":[""],"content":" 在繁杂的世界里，我们都需要一片净土。 为什么写博客，看过一个精妙的回答： 🥰于职业来讲，技术更迭太快，博客可以记录平时遇到的问题，供随时查看 🤩于个人来讲，可以作为名片，提高个人的影响力和知名度 🤖于生态来讲，丰富了互联网生态，为他人提供解决问题的思路 ","date":"2023-01-02","objectID":"/about/:0:0","tags":[""],"title":"关于博客","uri":"/about/"},{"categories":["年度总结"],"content":"📖前言 上次写总结还是21年12月写的述职报告，当时刚入职两个多月，也是我毕业后的第一份工作。转眼间一年过去了，若要用一句话形容22年的话，那就是： 新人职场初报道， 手低眼高乱手脚。 高瞻远瞩从长计， 尚需自身底子牢。 ","date":"2022-12-31","objectID":"/%E6%88%91%E7%9A%842022/:1:0","tags":["随笔"],"title":"我的2022","uri":"/%E6%88%91%E7%9A%842022/"},{"categories":["年度总结"],"content":"💼关于工作 22年是我工作的第一年，公司是一家做ASO的互联网小公司，我所在的部门从我入职时的四个人一直到我离职只剩了一个人，只能感慨互联网的风云莫测——业务好的时候就招人招人，不好的时候就裁员裁员。 我所在的部门总共四个人，负责B端平台的功能开发及维护。其中我们三个都是同年过来的，另外一个是负责人。 二一年末那段时间，受国家相关政策影响，一些捕鱼类游戏不能再在我们平台投放了，自那时起也许就注定了未来的走向。二二年三月份，部门被裁了一个同事，彼时我觉得毫无征兆同事怎么就被裁了。以前总是莫名听说，事业单位就是铁饭碗，我还不理解，这是我第一次感受到了在非事业单位的那种人人自危的危机感。六月份左右，恰逢疫情肆虐，那段时间一直是居家办公，负责人也在这段时间跳槽辞职了，毕竟公司这个业务已经是夕阳产业了。这时仅剩我和另外一位同事了，他也就顺理成章做了负责人。随后，这块业务日渐衰微，直到十一月份，公司进行了一场大规模裁员，大约裁了20%，当然也包括我。 至此，我的第一份长达一年零半个月的工作就告一段落了。 说下对于这份工作的体会： 首先，虽然岗位是Java开发，但由于这个业务已经是一个成熟的业务了，系统基本都很完善了，所以开发任务比较少，通常就是改改遗留的bug或者优化一下之前的逻辑，处理一下商务遇到的问题，以及，一个极度枯燥乏味毫无技术含量重复性机械性每天都要做的任务——对接接口。因此，这份工作就像是Java开发，但又不完全是Java开发。真正做的开发很少，更多是去修补bug。 对接接口简言之，一些游戏想要进行投放需要有相应的接口获取数据，我们需要对接口进行相应的配置，如果只是配置倒也挺快，最令人崩溃的是，对于每款游戏还需要进行游戏录屏，以及对游戏内的页面进行截屏。随后交给领导审核内容是否合规。基于这个既费时又费力又毫无技术可言的工作内容，我和另外一位同事早就有了离职的想法。从这个角度看，我被裁掉还赔了N+1赔偿金这确实是一件美事。 其次，没有开发任务导致了工作非常安逸。有很多时间可以用来学习，包括任何技术点以及公司的项目。这也是我一直没有跳槽的主要原因之一。 总之，这份工作在一定程度上锻炼了开发能力，更多的是改Bug的能力。同时有相当一部分机械性毫无技术性的任务。同时空暇时间较多，可以用来自我提升。 我记得很清楚，刚毕业找工作的时候，那时我没用过Redis，sql只会皮毛连join都不懂，对于Spring也都是一知半解。不管怎么说，工作带给我了最真实的项目经验，接触到了最常用到的一些技术。另，由于公司配备MacBook,用了一年发现MacBook还挺好用🤣 ","date":"2022-12-31","objectID":"/%E6%88%91%E7%9A%842022/:2:0","tags":["随笔"],"title":"我的2022","uri":"/%E6%88%91%E7%9A%842022/"},{"categories":["年度总结"],"content":"🧑‍💻关于发展 迷茫的年纪，不知道未来要做什么，短期来看是Java，但是目光放长远点，语言只是语言，语言是最上层最高级的一层，同时也是最容易更迭的，想要在领域深耕，底层才是根基。好比盖房子，地基没有打牢，无论盖多高都只是空中楼阁。 我不喜欢这个节奏太快的社会，这样的节奏让人变得非常浮躁。技术是为产品服务的，这就导致了很多时候做的东西能跑就行，我自己也不例外，总是觉得先跑起来，不行以后再改，然而通常的情况就是，没有以后了。关于行业，表面上好似大量人员涌向了程序员的赛道，这也导致了目前的面试不得不提高门槛，需要准备大量八股文。 但深扒一下就会发现，不过是鱼龙混杂罢了——阿猫阿狗都要过来分一杯羹。诚然，计算机基础知识繁杂，涉及广泛，晦涩难懂，工作中又难以用到。这就导致了没人愿意在这上边下功夫，进而也就导致了年纪大了将会缺乏竞争力，毕竟——你懂框架怎么用年轻人也懂，但如果你懂更底层的东西，我想大部分人都不懂了吧。因此，要想保持核心竞争力，就要做到融会贯通，从下到上，掌握了底层原理，才不会上层的语言所困。快即是慢，慢即是快。 另外，除了保持核心竞争力，还要有自己的发声口。自媒体时代，人人皆可做自媒体，但是，还是那句话，阿猫阿狗都要过来分一杯羹。这个时代鱼龙混杂，说是自媒体，大部分都是营销号罢了。这个时代，是一个越来越尊重知识的时代，持续进行输出，总归是能吸引到一批受众。如果说在以前金子有可能被埋没，但现在时代我坚信是金子总会发光。这是最好的时代，也是最坏的时代。 总之，关于发展，我总结出两点： 打铁还需自身硬 坚持内容输出 ","date":"2022-12-31","objectID":"/%E6%88%91%E7%9A%842022/:3:0","tags":["随笔"],"title":"我的2022","uri":"/%E6%88%91%E7%9A%842022/"},{"categories":["年度总结"],"content":"🏡关于生活 工作后才能体会到成年人的无奈。虽然第一份工作相对还是很轻松的，但是我能体会到理想和现实的距离。即便没有加班，回到家后仍然很疲惫。二二年到底都发生了什么，大部分时间被工作填充，剩余的时间除去琐事所剩无几。 我几乎从来不去清理手机照片，因为我觉得照片的意义就在于它就像一条完整的时间线，记录你在每个时间点的痕迹。如果单纯回忆，我能想到的只是零星的碎片。但是通过照片，我可以梳理出人生的轨迹。 应该没有男人不喜欢电子设备吧。细细数来，二一年十二月，先是组装了台电脑。我那台工作了四年的surface pro 4终于迎来了退休。然后开始入手3A游戏，从刺客信条2开始，到巫师3，随后是中土世界战争之影，最后一款是只玩了十个小时的泰坦陨落。我属于玩完一款才玩下一款那种，断断续续的，最终到泰坦陨落就没再玩过别的了。 刚入职那段时间被公司的狗咬了，导致我现在对柴犬都有一种恨意。 然后最大的印象就是天天做核酸吧，不记得从什么时候开始，就像是两三天续一次命，出门没有绿码都会没有安全感。也是居家那段时间，每天都居家无聊到怀疑人生。 后来买了块滑板，虽然大学玩了两年长板，但已经两年没滑过了，双翘对我来说就是个全新的领域。刚开始那段时间，我巴不得天天下班去滑板，但是刚开始也不清楚大家都在哪里玩。第一次去是在安贞门地铁站，后来知道了北土城，然后就是国家体育馆，这些地方离我住的地方很远，但那时几乎一周去个三次左右。通过滑板我认识的第一个朋友，是个00后，我觉得他性格挺好，一起玩过几次滑板，后来他有点窘迫，管我借了几百块钱。说下个月发工资还我，当时他在一家板店做助教，我马上就借了。后来就一直拖着，从那时起我就不再盲目信任别人了。 距离终究是个问题，来回两个小时，回到家几乎都凌晨了。后面就发现了附近的朝阳大悦城也有人，往后几乎都在这边玩了。差不多两个月的时候，我的Ollie(豚跳)第一次过了一立。这让我高兴了许久，这种纯粹的快乐是生活中鲜有的。这让我想起了大学一起玩板的时光，只能感叹时光匆匆。说到最近一次滑板，我也不记得是什么时候了。只记得我说了改天再约。是啊，我现在失业了啊。改天再约吧。 国庆前几天，女友来找我，我们一起过了生日。随后挑了一个工作日一起去了环球影城，印象最深的是哈利波特和霸天虎过山车，还是第一次坐头排，刺激就完了。 然后，正式失业那天是周五，上午办完离职手续，回家我躺床上躺了两个小时，我做了一个临时的决定。我要出去放松几天。后来就想去哪玩，本想先去郑州找发小再去杭州找同学，但那时我老家河南疫情很严重，回去就出不来了，就直接联系了同学，当天就赶了过去。人兢兢业业地工作，到底是为什么呢？房车可以满足人的物质，却填补不了精神的空虚。我想，正是这些可靠的朋友和同学才让人生显得不那么单调吧。 随后直到双十一，这时刚拿到赔偿金不久，换了一套键鼠，又忍痛剁手了一台Switch，重新领略了一遍塞尔达的魅力。 后面退租扣了两个月违约金，吃一堑长一智，下次签合同非读个百八遍的。 ","date":"2022-12-31","objectID":"/%E6%88%91%E7%9A%842022/:4:0","tags":["随笔"],"title":"我的2022","uri":"/%E6%88%91%E7%9A%842022/"},{"categories":["年度总结"],"content":"✨关于展望 好多事情，我总是三分钟热度，难以坚持下去，这是我最大的毛病。种一棵树最好的时间是十年前，其次就是现在。如果十年前我种下了那棵树，现在的我应该不会如此狼狈吧。想到十年后的我如果仍然如此狼狈，我现在只想种下那棵树。 十年前初中，我记得写过一篇作文，题目为“新年新气象”。作文写的是无非是如何如何好好学习，新的一年开个好头。我也知道，那些空洞的词藻都是装模作样给老师看的。十年后的展望，我衷心希望可以“新年新气象”。 在此立不完全的二三年Flag： 1.通用计算机知识 操作系统 计算机网络 计算机组成原理 数据结构和算法 2.探究Spring源码(待定) 3.保持博客\u0026公众号更新频率：一周二更/三更 ","date":"2022-12-31","objectID":"/%E6%88%91%E7%9A%842022/:5:0","tags":["随笔"],"title":"我的2022","uri":"/%E6%88%91%E7%9A%842022/"}]