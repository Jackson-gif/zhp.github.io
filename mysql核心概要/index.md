# MySQL核心概要


## 

# 1.关系型数据库

## 1.1E-R图

Entity-Relationship图，实体关系图。在设计数据库时通常要画出E-R图来表明实体之间的关系，实体之间存在`一对一`、`一对多`、`多对多`的关系。

##  1.2数据库范式

1. 第一范式：属性不可再分
2. 第二范式：在第一范式基础上，消除了非主属性对码的部分传递依赖。
3. 第三范式：在第二范式基础上，消除了非主属性对码的传递函数依赖。

## 1.3主键和外键

主键：一组数据的唯一标识，主键不能为null，不允许重复。

外键：用于和别的表建立联系，外键是另外一张表的主键，外键可以为null，可以重复，可以有多个外键。

## 1.4为什么不推荐使用外键

外键影响数据插入速度，不适合分布式高并发。分库分表情况下无法使用外键。

> 阿里巴巴开发手册明确规定，不允许使用外键。

## 1.5Drop、Delete、Truncate

Drop是直接删除表（包括数据），且无法回滚，速度最快。

Truncate是清空数据，自增id恢复为1，且无法回滚，速度次之。

delete是删除数据，删除所有数据不影响自增id，可以回滚，速度最慢，且会进行日志记录。

> 前两种属于DDL语言，后者属于DML语言。DDL语言是立即执行，DML语言需要提交后才能生效，因此DDL不能回滚，DML可以回滚。

# 2.MySQL

## 2.1MySQL架构

![](https://image.okzhp.xyz/img/20230227183941.png)

## 2.2MySQL存储引擎

5.5.5之前默认是MyISAM ，之后默认是InnoDB。

> 通过命令`show engines`查看MySQL支持的存储引擎。
>
> 通过命令 `select version()`查看MySQL版本。
>
> 通过命令`show variables like '%storage_engine%'`查看默认存储引擎。

两者区别？

1. 前者只支持表级锁，后者新增支持行级锁，并发度更高。
2. 前者不支持外键，后者支持。
3. 前者不支持事务，后者支持，实现了四个隔离级别。
4. 前者不支持数据库崩溃后的安全恢复，后者支持。
5. 前者不支持MVCC，后者支持。（MVVC可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能）
6. 索引实现不同。两者都是使用B+树作为索引结构，但实现方式有所不同。前者索引文件和数据文件是分离的，后者数据文件本身就是索引文件。
7. 后者性能更高。

## 2.3索引

索引的作用相当于目录，通过索引我们可以快速找到对应的数据。

**索引的优缺点？**

优点：查询速度快，通过唯一索引可以保证数据的唯一性。

缺点：创建和维护索引耗费时间和空间。

**索引的底层数据结构？**

1. hash表：缺点：无法范围查询无法顺序查询，因此一般不使用hash表作为底层数据结构。
2. B树，B+树：一般使用B+树作为底层数据结构。B树可以看作N叉树。

索引存储（索引树）示意图如下，Id为主键，K为普通索引。可以看出，索引的叶子节点存储的是主键值。主键也被称为聚簇索引，非主键索引也被成为辅助索引（二级索引）。通过普通索引查到主键后，根据主键去ID索引树再次查询，这个过程称为回表。

> 例如执行select * from T where k between 3 and 5，需要根据主键回表查询，但如果语句改成
>
> select ID from T where k between 3 and 5，就用到了覆盖索引，索引树k直接包含了要查询的ID，就无需再次回表查询，称为覆盖索引。

![](https://image.okzhp.xyz/img/20230227223931.png)

**索引的类型？**

1. 主键索引
2. 唯一索引：**唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。** 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。
3. 普通索引：普通的索引，可以为null。
4. 联合索引：多个列组成一个索引。
5. 覆盖索引：**覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。**
6. 全文索引：对文本内容进行分词，进行搜索。char、varchar、text上可以建立全文索引，一般不会使用。而是使用搜索引擎ElasticSearch 代替。

**最左前缀匹配原则?**

如果sql语句中用到了联合索引的最左边的索引，那么这条sql就可以使用这个联合索引去查询。

**建立索引应该如何考虑？**

1. 频繁查询的字段
2. 作为where条件的字段
3. 经常需要排序的字段
4. 经常用于连接的字段
5. 尽量不为null的字段

> 频繁更新的字段应该慎重建立索引；
>
> 索引并不是越多越多（索引维护成本较高），建议单张表不超过5个。
>
> 考虑使用联合索引而不是单列索引。

**常见的索引失效的情况？**

1. 使用`select *`查询
2. 创建了组合索引，但查询条件为满足最左原则。
3. 在索引列进行计算、函数、类型转换等操作
4. 以`%`开头的`Like`查询语句，比如`%abc`
5. 查询条件`or`前后使用的列没有索引。

## 2.4事务

**什么是事务？**简言之，要么都成功要么都失败。

```sql
# 开启一个事务
START TRANSACTION;
# 多条 SQL 语句
SQL1,SQL2...
## 提交事务
COMMIT;
```

在一个事务中，如果某条语句执行失败，将进行回滚；如果全部都执行成功，将进行提交。提交以后语句才会生效。

**事务的特性？**

`ACID`: 原子性，一致性，隔离性，持久性。

**并发事务带来的问题？**

1. 脏读：读取到其他事务还未提交的数据。
2. 不可重复读：一个事务内，前后读取的数据不一致（原因是该数据被别的事务更新了）。
3. 幻读：一个事务内，前后读取的数据不一致（原因是别的事务插入了新数据）。
4. 丢失修改：两个事务分别修改同一个数据，导致先修改的数据被后修改的数据覆盖丢失了。

**事务的隔离级别？MySQL默认隔离级别？**

共有四个隔离级别，由低到高分别是：

1. 读未提交
2. 读已提交：可以解决脏读。
3. 可重复读：可以解决脏读和不可重复读。
4. 可串行化：可以解决脏读、不可重复读、幻读。

MySQL默认是可重复读。

**MySQL如何实现事务并发控制？（MySQL如何实现四种隔离级别）**

通过锁和MVVC共同实现的。锁可以看作是悲观控制模式，MVVC可以看作是乐观控制的模式。

通过读锁和写锁，读读可以并行，读写和写写不可并行。InnoDB默认为行级锁，锁粒度更小，并发度更高。

MVVC是多版本并发控制方法，对一份数据存储多个版本，每个事务能看到自己应该看到的版本。MVVC具体实现可以参考：**[InnoDB存储引擎对MVCC的实现 | JavaGuide(Java面试+学习指南)](https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html)**



## 2.5锁

**表级锁：**MySQL 中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。

**行级锁：** MySQL 中锁定粒度最小的一种锁，是 **针对索引字段加的锁** ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。

> 共享锁和排他锁，也称为读锁和写锁。表级锁和行级锁都存在共享锁和排他锁两类。
>
> 其中多个读锁不冲突，但有写锁的话会冲突。

> 行级锁具体有哪些？
>
> - **记录锁（Record Lock）** ：也被称为记录锁，属于单个行记录上的锁。
> - **间隙锁（Gap Lock）** ：锁定一个范围，不包括记录本身。
> - **临键锁（Next-Key Lock）** ：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。
>
> **在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围**。
>
> 关于Next-Key Lock：[MySQL next-key lock 加锁范围是什么？ - 程序员小航 - 2021](https://segmentfault.com/a/1190000040129107)

**行级锁使用注意事项？**

行锁是针对索引字段加的锁，表锁是针对非索引字段加的锁。当执行upate或delete语句时，如果where条件没有命中唯一索引或者索引失效会导致全表扫描使用表锁。

有时使用了索引也会走全表扫描，这是因为MySQL优化器的原因。

## 2.6日志

mysql日志，主要包括错误日志，查询日志，慢查询日志，事务日志和归档日志。

> 慢查询日志，记录了查询时间较长的sql。默认是超过10秒。
>
> 事务日志：分为redo log（重做日志）和undo log（回滚日志）。
>
> 归档日志：不管用什么存储引擎，只要发生了表数据更新，都会产生 `binlog` 日志。`binlog` 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于`MySQL Server` 层。



`redo log`:

redo log让mysql有了崩溃恢复能力。redo log是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 `InnoDB` 存储引擎。

比如 `MySQL` 实例挂了或宕机了，重启时，`InnoDB`存储引擎会使用`redo log`恢复数据，保证数据的持久性与完整性。

`undo log`：

通过该日志可以执行回滚操作。

`binlog`:

`MySQL`数据库的**数据备份、主备、主主、主从**都离不开`binlog`，需要依靠`binlog`来同步数据，保证数据一致性。

## 2.7性能优化

**如何分析sql性能？**

使用`explain`查看sql执行过程，例如：

```sql
mysql> EXPLAIN SELECT `score`,`name` FROM `cus_order` ORDER BY `score` DESC;
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra          |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
|  1 | SIMPLE      | cus_order | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 997572 |   100.00 | Using filesort |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
1 row in set, 1 warning (0.00 sec)

```

如何分析explain结果，具体参考[MySQL执行计划分析 | JavaGuide(Java面试+学习指南)](https://javaguide.cn/database/mysql/mysql-query-execution-plan.html#如何获取执行计划)

**MySQL可以存储图片？**

可以存（直接存储图片的二进制数据），但不建议。会严重影响数据库性能。建议使用OSS或者自建文件存储服务（基于FastDFS或MinIO），数据库只存储文件地址信息，文件由文件存储服务负责存储。

MySQL高性能优化总结：[MySQL高性能优化规范建议总结 | JavaGuide(Java面试+学习指南)](https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html)


